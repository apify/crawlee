"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[43978],{24866:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var r=s(85893),i=s(11151),o=s(14959);const t={id:"upgrading-to-v3",title:"Upgrading to v3"},l=void 0,a={id:"upgrading/upgrading-to-v3",title:"Upgrading to v3",description:"This page summarizes most of the breaking changes between Crawlee (v3) and Apify SDK (v2). Crawlee is the spiritual successor to Apify SDK, so we decided to keep the versioning and release Crawlee as v3.",source:"@site/../docs/upgrading/upgrading_v3.md",sourceDirName:"upgrading",slug:"/upgrading/upgrading-to-v3",permalink:"/docs/next/upgrading/upgrading-to-v3",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Vlad Frangu",lastUpdatedAt:1704359836,formattedLastUpdatedAt:"Jan 4, 2024",frontMatter:{id:"upgrading-to-v3",title:"Upgrading to v3"},sidebar:"docs",previous:{title:"Upgrading to v2",permalink:"/docs/next/upgrading/upgrading-to-v2"}},c={},d=[{value:"Crawlee monorepo",id:"crawlee-monorepo",level:2},{value:"Installing Crawlee",id:"installing-crawlee",level:3},{value:"Full TypeScript support",id:"full-typescript-support",level:2},{value:"Docker build",id:"docker-build",level:3},{value:"Browser fingerprints",id:"browser-fingerprints",level:2},{value:"Session cookie method renames",id:"session-cookie-method-renames",level:2},{value:"Memory storage",id:"memory-storage",level:2},{value:"Purging of the default storage",id:"purging-of-the-default-storage",level:2},{value:"Renamed crawler options and interfaces",id:"renamed-crawler-options-and-interfaces",level:2},{value:"Context aware helpers",id:"context-aware-helpers",level:2},{value:"Enqueuing links",id:"enqueuing-links",level:3},{value:"Implicit <code>RequestQueue</code> instance",id:"implicit-requestqueue-instance",level:2},{value:"<code>crawler.addRequests()</code>",id:"crawleraddrequests",level:2},{value:"Less verbose error logging",id:"less-verbose-error-logging",level:2},{value:"<code>Request.label</code> shortcut",id:"requestlabel-shortcut",level:2},{value:"Removal of <code>requestAsBrowser</code>",id:"removal-of-requestasbrowser",level:2},{value:"How to use <code>sendRequest()</code>?",id:"how-to-use-sendrequest",level:3},{value:"Removed options",id:"removed-options",level:3},{value:"Renamed options",id:"renamed-options",level:3},{value:"<code>payload</code>",id:"payload",level:4},{value:"<code>ignoreSslErrors</code>",id:"ignoresslerrors",level:4},{value:"<code>header-generator</code> options",id:"header-generator-options",level:4},{value:"<code>timeoutSecs</code>",id:"timeoutsecs",level:4},{value:"<code>throwOnHttpErrors</code>",id:"throwonhttperrors",level:4},{value:"<code>decodeBody</code>",id:"decodebody",level:4},{value:"<code>abortFunction</code>",id:"abortfunction",level:4},{value:"Removal of browser pool plugin mixing",id:"removal-of-browser-pool-plugin-mixing",level:2},{value:"Handling requests outside of browser",id:"handling-requests-outside-of-browser",level:2},{value:"Logging",id:"logging",level:2},{value:"Auto-saved crawler state",id:"auto-saved-crawler-state",level:2},{value:"Apify SDK",id:"apify-sdk",level:2},{value:"Events",id:"events",level:3},{value:"Smaller/internal breaking changes",id:"smallerinternal-breaking-changes",level:2}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This page summarizes most of the breaking changes between Crawlee (v3) and Apify SDK (v2). Crawlee is the spiritual successor to Apify SDK, so we decided to keep the versioning and release Crawlee as v3."}),"\n",(0,r.jsxs)(n.admonition,{title:"Crawlee vs Apify SDK v2",type:"info",children:[(0,r.jsxs)(n.p,{children:["Up until version 3 of ",(0,r.jsx)(n.code,{children:"apify"}),", the package contained both scraping related tools and Apify platform related helper methods. With v3 we are splitting the whole project into two main parts:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/apify/crawlee",target:"_blank",rel:"noopener",children:"Crawlee"}),", the new web-scraping library, available as ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/crawlee",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"crawlee"})})," package on NPM"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/apify/apify-sdk-js",target:"_blank",rel:"noopener",children:"Apify SDK"}),", helpers for the Apify platform, available as ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/apify",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"apify"})})," package on NPM"]}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"crawlee-monorepo",children:"Crawlee monorepo"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/crawlee",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"crawlee"})})," package consists of several smaller packages, released separately under ",(0,r.jsx)(n.code,{children:"@crawlee"})," namespace:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/core",children:(0,r.jsx)(n.code,{children:"@crawlee/core"})}),": the base for all the crawler implementations, also contains things like ",(0,r.jsx)(n.code,{children:"Request"}),", ",(0,r.jsx)(n.code,{children:"RequestQueue"}),", ",(0,r.jsx)(n.code,{children:"RequestList"})," or ",(0,r.jsx)(n.code,{children:"Dataset"})," classes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/cheerio-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/cheerio"})}),": exports ",(0,r.jsx)(n.code,{children:"CheerioCrawler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/playwright-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/playwright"})}),": exports ",(0,r.jsx)(n.code,{children:"PlaywrightCrawler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/puppeteer-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/puppeteer"})}),": exports ",(0,r.jsx)(n.code,{children:"PuppeteerCrawler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/jsdom-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/jsdom"})}),": exports ",(0,r.jsx)(n.code,{children:"JSDOMCrawler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/basic-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/basic"})}),": exports ",(0,r.jsx)(n.code,{children:"BasicCrawler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/http-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/http"})}),": exports ",(0,r.jsx)(n.code,{children:"HttpCrawler"})," (which is used for creating ",(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/jsdom-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/jsdom"})})," and ",(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/cheerio-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/cheerio"})}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/browser-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/browser"})}),": exports ",(0,r.jsx)(n.code,{children:"BrowserCrawler"})," (which is used for creating ",(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/playwright-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/playwright"})})," and ",(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/puppeteer-crawler",children:(0,r.jsx)(n.code,{children:"@crawlee/puppeteer"})}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/memory-storage",children:(0,r.jsx)(n.code,{children:"@crawlee/memory-storage"})}),": ",(0,r.jsx)(n.a,{href:"https://npmjs.com/package/@apify/storage-local",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"@apify/storage-local"})})," alternative"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/browser-pool",children:(0,r.jsx)(n.code,{children:"@crawlee/browser-pool"})}),": previously ",(0,r.jsx)(n.a,{href:"https://npmjs.com/package/browser-pool",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"browser-pool"})})," package"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/utils",children:(0,r.jsx)(n.code,{children:"@crawlee/utils"})}),": utility methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/types",children:(0,r.jsx)(n.code,{children:"@crawlee/types"})}),": holds TS interfaces mainly about the ",(0,r.jsx)(n.a,{href:"https://crawlee.dev/api/core/interface/StorageClient",children:(0,r.jsx)(n.code,{children:"StorageClient"})})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"installing-crawlee",children:"Installing Crawlee"}),"\n",(0,r.jsxs)(n.p,{children:["Most of the Crawlee packages are extending and reexporting each other, so it's enough to install just the one you plan on using, e.g. ",(0,r.jsx)(n.code,{children:"@crawlee/playwright"})," if you plan on using ",(0,r.jsx)(n.code,{children:"playwright"})," - it already contains everything from the ",(0,r.jsx)(n.code,{children:"@crawlee/browser"})," package, which includes everything from ",(0,r.jsx)(n.code,{children:"@crawlee/basic"}),", which includes everything from ",(0,r.jsx)(n.code,{children:"@crawlee/core"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If we don't care much about additional code being pulled in, we can just use the ",(0,r.jsx)(n.code,{children:"crawlee"})," meta-package, which contains (re-exports) most of the ",(0,r.jsx)(n.code,{children:"@crawlee/*"})," packages, and therefore contains all the crawler classes."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install crawlee\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Or if all we need is cheerio support, we can install only ",(0,r.jsx)(n.code,{children:"@crawlee/cheerio"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @crawlee/cheerio\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When using ",(0,r.jsx)(n.code,{children:"playwright"})," or ",(0,r.jsx)(n.code,{children:"puppeteer"}),", we still need to install those dependencies explicitly - this allows the users to be in control of which version will be used."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install crawlee playwright\n# or npm install @crawlee/playwright playwright\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively we can also use the ",(0,r.jsx)(n.code,{children:"crawlee"})," meta-package which contains (re-exports) most of the ",(0,r.jsx)(n.code,{children:"@crawlee/*"})," packages, and therefore contains all the crawler classes."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Sometimes you might want to use some utility methods from ",(0,r.jsx)(n.code,{children:"@crawlee/utils"}),", so you might want to install that as well. This package contains some utilities that were previously available under ",(0,r.jsx)(n.code,{children:"Apify.utils"}),". Browser related utilities can be also found in the crawler packages (e.g. ",(0,r.jsx)(n.code,{children:"@crawlee/playwright"}),")."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"full-typescript-support",children:"Full TypeScript support"}),"\n",(0,r.jsxs)(n.p,{children:["Both Crawlee and Apify SDK are full TypeScript rewrite, so they include up-to-date types in the package. For your TypeScript crawlers we recommend using our predefined TypeScript configuration from ",(0,r.jsx)(n.code,{children:"@apify/tsconfig"})," package. Don't forget to set the ",(0,r.jsx)(n.code,{children:"module"})," and ",(0,r.jsx)(n.code,{children:"target"})," to ",(0,r.jsx)(n.code,{children:"ES2022"})," or above to be able to use top level await."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"@apify/tsconfig"})," config has ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/tsconfig#noImplicitAny",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"noImplicitAny"})})," enabled, you might want to disable it during the initial development as it will cause build failures if you left some unused local variables in your code."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:'title="tsconfig.json"',children:'{\n    "extends": "@apify/tsconfig",\n    "compilerOptions": {\n        "module": "ES2022",\n        "target": "ES2022",\n        "outDir": "dist",\n        "lib": ["DOM"]\n    },\n    "include": [\n        "./src/**/*"\n    ]\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"docker-build",children:"Docker build"}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"Dockerfile"})," we recommend using multi-stage build, so you don't install the dev dependencies like TypeScript in your final image:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dockerfile",metastring:'title="Dockerfile"',children:'# using multistage build, as we need dev deps to build the TS source code\nFROM apify/actor-node:16 AS builder\n\n# copy all files, install all dependencies (including dev deps) and build the project\nCOPY . ./\nRUN npm install --include=dev \\\n    && npm run build\n\n# create final image\nFROM apify/actor-node:16\n# copy only necessary files\nCOPY --from=builder /usr/src/app/package*.json ./\nCOPY --from=builder /usr/src/app/README.md ./\nCOPY --from=builder /usr/src/app/dist ./dist\nCOPY --from=builder /usr/src/app/apify.json ./apify.json\nCOPY --from=builder /usr/src/app/INPUT_SCHEMA.json ./INPUT_SCHEMA.json\n\n# install only prod deps\nRUN npm --quiet set progress=false \\\n    && npm install --only=prod --no-optional \\\n    && echo "Installed NPM packages:" \\\n    && (npm list --only=prod --no-optional --all || true) \\\n    && echo "Node.js version:" \\\n    && node --version \\\n    && echo "NPM version:" \\\n    && npm --version\n\n# run compiled code\nCMD npm run start:prod\n'})}),"\n",(0,r.jsx)(n.h2,{id:"browser-fingerprints",children:"Browser fingerprints"}),"\n",(0,r.jsxs)(n.p,{children:["Previously we had a magical ",(0,r.jsx)(n.code,{children:"stealth"})," option in the puppeteer crawler that enabled several tricks aiming to mimic the real users as much as possible. While this worked to a certain degree, we decided to replace it with generated browser fingerprints."]}),"\n",(0,r.jsxs)(n.p,{children:["In case we don't want to have dynamic fingerprints, we can disable this behaviour via ",(0,r.jsx)(n.code,{children:"useFingerprints"})," in ",(0,r.jsx)(n.code,{children:"browserPoolOptions"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const crawler = new PlaywrightCrawler({\n   browserPoolOptions: {\n       useFingerprints: false,\n   },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"session-cookie-method-renames",children:"Session cookie method renames"}),"\n",(0,r.jsxs)(n.p,{children:["Previously, if we wanted to get or add cookies for the session that would be used for the request, we had to call ",(0,r.jsx)(n.code,{children:"session.getPuppeteerCookies()"})," or ",(0,r.jsx)(n.code,{children:"session.setPuppeteerCookies()"}),". Since this method could be used for any of our crawlers, not just ",(0,r.jsx)(n.code,{children:"PuppeteerCrawler"}),", the methods have been renamed to ",(0,r.jsx)(n.code,{children:"session.getCookies()"})," and ",(0,r.jsx)(n.code,{children:"session.setCookies()"})," respectively. Otherwise, their usage is exactly the same!"]}),"\n",(0,r.jsx)(n.h2,{id:"memory-storage",children:"Memory storage"}),"\n",(0,r.jsxs)(n.p,{children:["When we store some data or intermediate state (like the one ",(0,r.jsx)(n.code,{children:"RequestQueue"})," holds), we now use ",(0,r.jsx)(n.code,{children:"@crawlee/memory-storage"})," by default. It is an alternative to the ",(0,r.jsx)(n.code,{children:"@apify/storage-local"}),", that stores the state inside memory (as opposed to SQLite database used by ",(0,r.jsx)(n.code,{children:"@apify/storage-local"}),"). While the state is stored in memory, it also dumps it to the file system, so we can observe it, as well as respects the existing data stored in KeyValueStore (e.g. the ",(0,r.jsx)(n.code,{children:"INPUT.json"})," file)."]}),"\n",(0,r.jsxs)(n.p,{children:["When we want to run the crawler on Apify platform, we need to use ",(0,r.jsx)(n.code,{children:"Actor.init"})," or ",(0,r.jsx)(n.code,{children:"Actor.main"}),", which will automatically switch the storage client to ",(0,r.jsx)(n.code,{children:"ApifyClient"})," when on the Apify platform."]}),"\n",(0,r.jsxs)(n.p,{children:["We can still use the ",(0,r.jsx)(n.code,{children:"@apify/storage-local"}),", to do it, first install it pass it to the ",(0,r.jsx)(n.code,{children:"Actor.init"})," or ",(0,r.jsx)(n.code,{children:"Actor.main"})," options:"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@apify/storage-local"})," v2.1.0+ is required for Crawlee"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { Actor } from 'apify';\nimport { ApifyStorageLocal } from '@apify/storage-local';\n\nconst storage = new ApifyStorageLocal(/* options like `enableWalMode` belong here */);\nawait Actor.init({ storage });\n"})}),"\n",(0,r.jsx)(n.h2,{id:"purging-of-the-default-storage",children:"Purging of the default storage"}),"\n",(0,r.jsxs)(n.p,{children:["Previously the state was preserved between local runs, and we had to use ",(0,r.jsx)(n.code,{children:"--purge"})," argument of the ",(0,r.jsx)(n.code,{children:"apify-cli"}),". With Crawlee, this is now the default behaviour, we purge the storage automatically on ",(0,r.jsx)(n.code,{children:"Actor.init/main"})," call. We can opt out of it via ",(0,r.jsx)(n.code,{children:"purge: false"})," in the ",(0,r.jsx)(n.code,{children:"Actor.init"})," options."]}),"\n",(0,r.jsx)(n.h2,{id:"renamed-crawler-options-and-interfaces",children:"Renamed crawler options and interfaces"}),"\n",(0,r.jsx)(n.p,{children:"Some options were renamed to better reflect what they do. We still support all the old parameter names too, but not at the TS level."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"handleRequestFunction"})," -> ",(0,r.jsx)(n.code,{children:"requestHandler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"handlePageFunction"})," -> ",(0,r.jsx)(n.code,{children:"requestHandler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"handleRequestTimeoutSecs"})," -> ",(0,r.jsx)(n.code,{children:"requestHandlerTimeoutSecs"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"handlePageTimeoutSecs"})," -> ",(0,r.jsx)(n.code,{children:"requestHandlerTimeoutSecs"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"requestTimeoutSecs"})," -> ",(0,r.jsx)(n.code,{children:"navigationTimeoutSecs"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"handleFailedRequestFunction"})," -> ",(0,r.jsx)(n.code,{children:"failedRequestHandler"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We also renamed the crawling context interfaces, so they follow the same convention and are more meaningful:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CheerioHandlePageInputs"})," -> ",(0,r.jsx)(n.code,{children:"CheerioCrawlingContext"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PlaywrightHandlePageFunction"})," -> ",(0,r.jsx)(n.code,{children:"PlaywrightCrawlingContext"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PuppeteerHandlePageFunction"})," -> ",(0,r.jsx)(n.code,{children:"PuppeteerCrawlingContext"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"context-aware-helpers",children:"Context aware helpers"}),"\n",(0,r.jsxs)(n.p,{children:["Some utilities previously available under ",(0,r.jsx)(n.code,{children:"Apify.utils"})," namespace are now moved to the crawling context and are ",(0,r.jsx)(n.em,{children:"context aware"}),". This means they have some parameters automatically filled in from the context, like the current ",(0,r.jsx)(n.code,{children:"Request"})," instance or current ",(0,r.jsx)(n.code,{children:"Page"})," object, or the ",(0,r.jsx)(n.code,{children:"RequestQueue"})," bound to the crawler."]}),"\n",(0,r.jsx)(n.h3,{id:"enqueuing-links",children:"Enqueuing links"}),"\n",(0,r.jsxs)(n.p,{children:["One common helper that received more attention is the ",(0,r.jsx)(n.code,{children:"enqueueLinks"}),". As mentioned above, it is context aware - we no longer need pass in the ",(0,r.jsx)(n.code,{children:"requestQueue"})," or ",(0,r.jsx)(n.code,{children:"page"})," arguments (or the cheerio handle ",(0,r.jsx)(n.code,{children:"$"}),"). In addition to that, it now offers 3 enqueuing strategies:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"EnqueueStrategy.All"})," (",(0,r.jsx)(n.code,{children:"'all'"}),"): Matches any URLs found"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"EnqueueStrategy.SameHostname"})," (",(0,r.jsx)(n.code,{children:"'same-hostname'"}),") Matches any URLs that have the same subdomain as the base URL (default)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"EnqueueStrategy.SameDomain"})," (",(0,r.jsx)(n.code,{children:"'same-domain'"}),") Matches any URLs that have the same domain name. For example, ",(0,r.jsx)(n.code,{children:"https://wow.an.example.com"})," and ",(0,r.jsx)(n.code,{children:"https://example.com"})," will both be matched for a base url of ",(0,r.jsx)(n.code,{children:"https://example.com"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This means we can even call ",(0,r.jsx)(n.code,{children:"enqueueLinks()"})," without any parameters. By default, it will go through all the links found on current page and filter only those targeting the same subdomain."]}),"\n",(0,r.jsx)(n.p,{children:"Moreover, we can specify patterns the URL should match via globs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const crawler = new PlaywrightCrawler({\n    async requestHandler({ enqueueLinks }) {\n        await enqueueLinks({\n            globs: ['https://crawlee.dev/*/*'],\n            // we can also use `regexps` and `pseudoUrls` keys here\n        });\n    },\n});\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"implicit-requestqueue-instance",children:["Implicit ",(0,r.jsx)(n.code,{children:"RequestQueue"})," instance"]}),"\n",(0,r.jsxs)(n.p,{children:["All crawlers now have the ",(0,r.jsx)(n.code,{children:"RequestQueue"})," instance automatically available via ",(0,r.jsx)(n.code,{children:"crawler.getRequestQueue()"})," method. It will create the instance for you if it does not exist yet. This mean we no longer need to create the ",(0,r.jsx)(n.code,{children:"RequestQueue"})," instance manually, and we can just use ",(0,r.jsx)(n.code,{children:"crawler.addRequests()"})," method described underneath."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["We can still create the ",(0,r.jsx)(n.code,{children:"RequestQueue"})," explicitly, the ",(0,r.jsx)(n.code,{children:"crawler.getRequestQueue()"})," method will respect that and return the instance provided via crawler options."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"crawleraddrequests",children:(0,r.jsx)(n.code,{children:"crawler.addRequests()"})}),"\n",(0,r.jsxs)(n.p,{children:["We can now add multiple requests in batches. The newly added ",(0,r.jsx)(n.code,{children:"addRequests"})," method will handle everything for us. It enqueues the first 1000 requests and resolves, while continuing with the rest in the background, again in a smaller 1000 items batches, so we don't fall into any API rate limits. This means the crawling will start almost immediately (within few seconds at most), something previously possible only with a combination of ",(0,r.jsx)(n.code,{children:"RequestQueue"})," and ",(0,r.jsx)(n.code,{children:"RequestList"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// will resolve right after the initial batch of 1000 requests is added\nconst result = await crawler.addRequests([/* many requests, can be even millions */]);\n\n// if we want to wait for all the requests to be added, we can await the `waitForAllRequestsToBeAdded` promise\nawait result.waitForAllRequestsToBeAdded;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"less-verbose-error-logging",children:"Less verbose error logging"}),"\n",(0,r.jsxs)(n.p,{children:["Previously an error thrown from inside request handler resulted in full error object being logged. With Crawlee, we log only the error message as a warning as long as we know the request will be retried. If you want to enable verbose logging like in v2, use the ",(0,r.jsx)(n.code,{children:"CRAWLEE_VERBOSE_LOG"})," env var."]}),"\n",(0,r.jsxs)(n.h2,{id:"requestlabel-shortcut",children:[(0,r.jsx)(n.code,{children:"Request.label"})," shortcut"]}),"\n",(0,r.jsxs)(n.p,{children:["Labeling requests used to work via the ",(0,r.jsx)(n.code,{children:"Request.userData"})," object. With Crawlee, we can also use the ",(0,r.jsx)(n.code,{children:"Request.label"})," shortcut. It is implemented as a ",(0,r.jsx)(n.code,{children:"get/set"})," pair, using the value from ",(0,r.jsx)(n.code,{children:"Request.userData"}),". The support for this shortcut is also added to the ",(0,r.jsx)(n.code,{children:"enqueueLinks"})," options interface."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"async requestHandler({ request, enqueueLinks }) {\n    if (request.label !== 'DETAIL') {\n        await enqueueLinks({\n            globs: ['...'],\n            label: 'DETAIL',\n        });\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"removal-of-requestasbrowser",children:["Removal of ",(0,r.jsx)(n.code,{children:"requestAsBrowser"})]}),"\n",(0,r.jsxs)(n.p,{children:["In v1 we replaced the underlying implementation of ",(0,r.jsx)(n.code,{children:"requestAsBrowser"})," to be just a proxy over calling ",(0,r.jsx)(n.a,{href:"https://github.com/apify/got-scraping",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"got-scraping"})})," - our custom extension to ",(0,r.jsx)(n.code,{children:"got"})," that tries to mimic the real browsers as much as possible. With v3, we are removing the ",(0,r.jsx)(n.code,{children:"requestAsBrowser"}),", encouraging the use of ",(0,r.jsx)(n.a,{href:"https://github.com/apify/got-scraping",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"got-scraping"})})," directly."]}),"\n",(0,r.jsxs)(n.p,{children:["For easier migration, we also added ",(0,r.jsx)(n.code,{children:"context.sendRequest()"})," helper that allows processing the context bound ",(0,r.jsx)(n.code,{children:"Request"})," object through ",(0,r.jsx)(n.a,{href:"https://github.com/apify/got-scraping",target:"_blank",rel:"noopener",children:(0,r.jsx)(n.code,{children:"got-scraping"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const crawler = new BasicCrawler({\n    async requestHandler({ sendRequest, log }) {\n        // we can use the options parameter to override gotScraping options\n        const res = await sendRequest({ responseType: 'json' });\n        log.info('received body', res.body);\n    },\n});\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"how-to-use-sendrequest",children:["How to use ",(0,r.jsx)(n.code,{children:"sendRequest()"}),"?"]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/next/guides/got-scraping",children:"the Got Scraping guide"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"removed-options",children:"Removed options"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useInsecureHttpParser"})," option has been removed. It's permanently set to ",(0,r.jsx)(n.code,{children:"true"})," in order to better mimic browsers' behavior."]}),"\n",(0,r.jsxs)(n.p,{children:["Got Scraping automatically performs protocol negotiation, hence we removed the ",(0,r.jsx)(n.code,{children:"useHttp2"})," option. It's set to ",(0,r.jsx)(n.code,{children:"true"})," - 100% of browsers nowadays are capable of HTTP/2 requests. Oh, more and more of the web is using it too!"]}),"\n",(0,r.jsx)(n.h3,{id:"renamed-options",children:"Renamed options"}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"requestAsBrowser"})," approach, some of the options were named differently. Here's a list of renamed options:"]}),"\n",(0,r.jsx)(n.h4,{id:"payload",children:(0,r.jsx)(n.code,{children:"payload"})}),"\n",(0,r.jsxs)(n.p,{children:["This options represents the body to send. It could be a ",(0,r.jsx)(n.code,{children:"string"})," or a ",(0,r.jsx)(n.code,{children:"Buffer"}),". However, there is no ",(0,r.jsx)(n.code,{children:"payload"})," option anymore. You need to use ",(0,r.jsx)(n.code,{children:"body"})," instead. Or, if you wish to send JSON, ",(0,r.jsx)(n.code,{children:"json"}),". Here's an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Before:\nawait Apify.utils.requestAsBrowser({ \u2026, payload: 'Hello, world!' });\nawait Apify.utils.requestAsBrowser({ \u2026, payload: Buffer.from('c0ffe', 'hex') });\nawait Apify.utils.requestAsBrowser({ \u2026, json: { hello: 'world' } });\n\n// After:\nawait gotScraping({ \u2026, body: 'Hello, world!' });\nawait gotScraping({ \u2026, body: Buffer.from('c0ffe', 'hex') });\nawait gotScraping({ \u2026, json: { hello: 'world' } });\n"})}),"\n",(0,r.jsx)(n.h4,{id:"ignoresslerrors",children:(0,r.jsx)(n.code,{children:"ignoreSslErrors"})}),"\n",(0,r.jsxs)(n.p,{children:["It has been renamed to ",(0,r.jsx)(n.code,{children:"https.rejectUnauthorized"}),". By default, it's set to ",(0,r.jsx)(n.code,{children:"false"})," for convenience. However, if you want to make sure the connection is secure, you can do the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Before:\nawait Apify.utils.requestAsBrowser({ \u2026, ignoreSslErrors: false });\n\n// After:\nawait gotScraping({ \u2026, https: { rejectUnauthorized: true } });\n"})}),"\n",(0,r.jsx)(n.p,{children:"Please note: the meanings are opposite! So we needed to invert the values as well."}),"\n",(0,r.jsxs)(n.h4,{id:"header-generator-options",children:[(0,r.jsx)(n.code,{children:"header-generator"})," options"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useMobileVersion"}),", ",(0,r.jsx)(n.code,{children:"languageCode"})," and ",(0,r.jsx)(n.code,{children:"countryCode"})," no longer exist. Instead, you need to use ",(0,r.jsx)(n.code,{children:"headerGeneratorOptions"})," directly:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Before:\nawait Apify.utils.requestAsBrowser({\n    \u2026,\n    useMobileVersion: true,\n    languageCode: 'en',\n    countryCode: 'US',\n});\n\n// After:\nawait gotScraping({\n    \u2026,\n    headerGeneratorOptions: {\n        devices: ['mobile'], // or ['desktop']\n        locales: ['en-US'],\n    },\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"timeoutsecs",children:(0,r.jsx)(n.code,{children:"timeoutSecs"})}),"\n",(0,r.jsxs)(n.p,{children:["In order to set a timeout, use ",(0,r.jsx)(n.code,{children:"timeout.request"})," (which is ",(0,r.jsx)(n.strong,{children:"milliseconds"})," now)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Before:\nawait Apify.utils.requestAsBrowser({\n    \u2026,\n    timeoutSecs: 30,\n});\n\n// After:\nawait gotScraping({\n    \u2026,\n    timeout: {\n        request: 30 * 1000,\n    },\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"throwonhttperrors",children:(0,r.jsx)(n.code,{children:"throwOnHttpErrors"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"throwOnHttpErrors"})," \u2192 ",(0,r.jsx)(n.code,{children:"throwHttpErrors"}),". This options throws on unsuccessful HTTP status codes, for example ",(0,r.jsx)(n.code,{children:"404"}),". By default, it's set to ",(0,r.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"decodebody",children:(0,r.jsx)(n.code,{children:"decodeBody"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"decodeBody"})," \u2192 ",(0,r.jsx)(n.code,{children:"decompress"}),". This options decompresses the body. Defaults to ",(0,r.jsx)(n.code,{children:"true"})," - please do not change this or websites will break (unless you know what you're doing!)."]}),"\n",(0,r.jsx)(n.h4,{id:"abortfunction",children:(0,r.jsx)(n.code,{children:"abortFunction"})}),"\n",(0,r.jsxs)(n.p,{children:["This function used to make the promise throw on specific responses, if it returned ",(0,r.jsx)(n.code,{children:"true"}),". However, it wasn't that useful."]}),"\n",(0,r.jsx)(n.p,{children:"You probably want to cancel the request instead, which you can do in the following way:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const promise = gotScraping(\u2026);\n\npromise.on('request', request => {\n    // Please note this is not a Got Request instance, but a ClientRequest one.\n    // https://nodejs.org/api/http.html#class-httpclientrequest\n\n    if (request.protocol !== 'https:') {\n        // Unsecure request, abort.\n        promise.cancel();\n\n        // If you set `isStream` to `true`, please use `stream.destroy()` instead.\n    }\n});\n\nconst response = await promise;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"removal-of-browser-pool-plugin-mixing",children:"Removal of browser pool plugin mixing"}),"\n",(0,r.jsx)(n.p,{children:"Previously, you were able to have a browser pool that would mix Puppeteer and Playwright plugins (or even your own custom plugins if you've built any). As of this version, that is no longer allowed, and creating such a browser pool will cause an error to be thrown (it's expected that all plugins that will be used are of the same type)."}),"\n",(0,r.jsx)(n.admonition,{title:"Confused?",type:"info",children:(0,r.jsx)(n.p,{children:"As an example, this change disallows a pool to mix Puppeteer with Playwright. You can still create pools that use multiple Playwright plugins, each with a different launcher if you want!"})}),"\n",(0,r.jsx)(n.h2,{id:"handling-requests-outside-of-browser",children:"Handling requests outside of browser"}),"\n",(0,r.jsxs)(n.p,{children:["One small feature worth mentioning is the ability to handle requests with browser crawlers outside the browser. To do that, we can use a combination of ",(0,r.jsx)(n.code,{children:"Request.skipNavigation"})," and ",(0,r.jsx)(n.code,{children:"context.sendRequest()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Take a look at how to achieve this by checking out the ",(0,r.jsx)(n.a,{href:"../examples/skip-navigation",children:"Skipping navigation for certain requests"})," example!"]}),"\n",(0,r.jsx)(n.h2,{id:"logging",children:"Logging"}),"\n",(0,r.jsxs)(n.p,{children:["Crawlee exports the default ",(0,r.jsx)(n.code,{children:"log"})," instance directly as a named export. We also have a scoped ",(0,r.jsx)(n.code,{children:"log"})," instance provided in the crawling context - this one will log messages prefixed with the crawler name and should be preferred for logging inside the request handler."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const crawler = new CheerioCrawler({\n    async requestHandler({ log, request }) {\n        log.info(`Opened ${request.loadedUrl}`);\n    },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"auto-saved-crawler-state",children:"Auto-saved crawler state"}),"\n",(0,r.jsxs)(n.p,{children:["Every crawler instance now has ",(0,r.jsx)(n.code,{children:"useState()"})," method that will return a state object we can use. It will be automatically saved when ",(0,r.jsx)(n.code,{children:"persistState"})," event occurs. The value is cached, so we can freely call this method multiple times and get the exact same reference. No need to worry about saving the value either, as it will happen automatically."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const crawler = new CheerioCrawler({\n    async requestHandler({ crawler }) {\n        const state = await crawler.useState({ foo: [] as number[] });\n        // just change the value, no need to care about saving it\n        state.foo.push(123);\n    },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"apify-sdk",children:"Apify SDK"}),"\n",(0,r.jsxs)(n.p,{children:["The Apify platform helpers can be now found in the Apify SDK (",(0,r.jsx)(n.code,{children:"apify"})," NPM package). It exports the ",(0,r.jsx)(n.code,{children:"Actor"})," class that offers following static helpers:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ApifyClient"})," shortcuts: ",(0,r.jsx)(n.code,{children:"addWebhook()"}),", ",(0,r.jsx)(n.code,{children:"call()"}),", ",(0,r.jsx)(n.code,{children:"callTask()"}),", ",(0,r.jsx)(n.code,{children:"metamorph()"})]}),"\n",(0,r.jsxs)(n.li,{children:["helpers for running on Apify platform: ",(0,r.jsx)(n.code,{children:"init()"}),", ",(0,r.jsx)(n.code,{children:"exit()"}),", ",(0,r.jsx)(n.code,{children:"fail()"}),", ",(0,r.jsx)(n.code,{children:"main()"}),", ",(0,r.jsx)(n.code,{children:"isAtHome()"}),", ",(0,r.jsx)(n.code,{children:"createProxyConfiguration()"})]}),"\n",(0,r.jsxs)(n.li,{children:["storage support: ",(0,r.jsx)(n.code,{children:"getInput()"}),", ",(0,r.jsx)(n.code,{children:"getValue()"}),", ",(0,r.jsx)(n.code,{children:"openDataset()"}),", ",(0,r.jsx)(n.code,{children:"openKeyValueStore()"}),", ",(0,r.jsx)(n.code,{children:"openRequestQueue()"}),", ",(0,r.jsx)(n.code,{children:"pushData()"}),", ",(0,r.jsx)(n.code,{children:"setValue()"})]}),"\n",(0,r.jsxs)(n.li,{children:["events support: ",(0,r.jsx)(n.code,{children:"on()"}),", ",(0,r.jsx)(n.code,{children:"off()"})]}),"\n",(0,r.jsxs)(n.li,{children:["other utilities: ",(0,r.jsx)(n.code,{children:"getEnv()"}),", ",(0,r.jsx)(n.code,{children:"newClient()"}),", ",(0,r.jsx)(n.code,{children:"reboot()"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Actor.main"})," is now just a syntax sugar around calling ",(0,r.jsx)(n.code,{children:"Actor.init()"})," at the beginning and ",(0,r.jsx)(n.code,{children:"Actor.exit()"})," at the end (plus wrapping the user function in try/catch block). All those methods are async and should be awaited - with node 16 we can use the top level await for that. In other words, following is equivalent:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { Actor } from 'apify';\n\nawait Actor.init();\n// your code\nawait Actor.exit('Crawling finished!');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { Actor } from 'apify';\n\nawait Actor.main(async () => {\n    // your code\n}, { statusMessage: 'Crawling finished!' });\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Actor.init()"})," will conditionally set the storage implementation of Crawlee to the ",(0,r.jsx)(n.code,{children:"ApifyClient"})," when running on the Apify platform, or keep the default (memory storage) implementation otherwise. It will also subscribe to the websocket events (or mimic them locally). ",(0,r.jsx)(n.code,{children:"Actor.exit()"})," will handle the tear down and calls ",(0,r.jsx)(n.code,{children:"process.exit()"})," to ensure our process won't hang indefinitely for some reason."]}),"\n",(0,r.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,r.jsxs)(n.p,{children:["Apify SDK (v2) exports ",(0,r.jsx)(n.code,{children:"Apify.events"}),", which is an ",(0,r.jsx)(n.code,{children:"EventEmitter"})," instance. With Crawlee, the events are managed by ",(0,r.jsx)(o.Z,{to:"core/class/EventManager",children:(0,r.jsx)(n.code,{children:"EventManager"})})," class instead. We can either access it via ",(0,r.jsx)(n.code,{children:"Actor.eventManager"})," getter, or use ",(0,r.jsx)(n.code,{children:"Actor.on"})," and ",(0,r.jsx)(n.code,{children:"Actor.off"})," shortcuts instead."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"-Apify.events.on(...);\n+Actor.on(...);\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["We can also get the ",(0,r.jsx)(o.Z,{to:"core/class/EventManager",children:(0,r.jsx)(n.code,{children:"EventManager"})})," instance via ",(0,r.jsx)(n.code,{children:"Configuration.getEventManager()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In addition to the existing events, we now have an ",(0,r.jsx)(n.code,{children:"exit"})," event fired when calling ",(0,r.jsx)(n.code,{children:"Actor.exit()"})," (which is called at the end of ",(0,r.jsx)(n.code,{children:"Actor.main()"}),"). This event allows you to gracefully shut down any resources when ",(0,r.jsx)(n.code,{children:"Actor.exit"})," is called."]}),"\n",(0,r.jsx)(n.h2,{id:"smallerinternal-breaking-changes",children:"Smaller/internal breaking changes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Apify.call()"})," is now just a shortcut for running ",(0,r.jsx)(n.code,{children:"ApifyClient.actor(actorId).call(input, options)"}),", while also taking the token inside env vars into account"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Apify.callTask()"})," is now just a shortcut for running ",(0,r.jsx)(n.code,{children:"ApifyClient.task(taskId).call(input, options)"}),", while also taking the token inside env vars into account"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Apify.metamorph()"})," is now just a shortcut for running ",(0,r.jsx)(n.code,{children:"ApifyClient.task(taskId).metamorph(input, options)"}),", while also taking the ACTOR_RUN_ID inside env vars into account"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Apify.waitForRunToFinish()"})," has been removed, use ",(0,r.jsx)(n.code,{children:"ApifyClient.waitForFinish()"})," instead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Actor.main/init"})," purges the storage by default"]}),"\n",(0,r.jsxs)(n.li,{children:["remove ",(0,r.jsx)(n.code,{children:"purgeLocalStorage"})," helper, move purging to the storage class directly","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"StorageClient"})," interface now has optional ",(0,r.jsx)(n.code,{children:"purge"})," method"]}),"\n",(0,r.jsxs)(n.li,{children:["purging happens automatically via ",(0,r.jsx)(n.code,{children:"Actor.init()"})," (you can opt out via ",(0,r.jsx)(n.code,{children:"purge: false"})," in the options of ",(0,r.jsx)(n.code,{children:"init/main"})," methods)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"QueueOperationInfo.request"})," is no longer available"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Request.handledAt"})," is now string date in ISO format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Request.inProgress"})," and ",(0,r.jsx)(n.code,{children:"Request.reclaimed"})," are now ",(0,r.jsx)(n.code,{children:"Set"}),"s instead of POJOs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"injectUnderscore"})," from puppeteer utils has been removed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"APIFY_MEMORY_MBYTES"})," is no longer taken into account, use ",(0,r.jsx)(n.code,{children:"CRAWLEE_AVAILABLE_MEMORY_RATIO"})," instead"]}),"\n",(0,r.jsxs)(n.li,{children:["some ",(0,r.jsx)(n.code,{children:"AutoscaledPool"})," options are no longer available:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cpuSnapshotIntervalSecs"})," and ",(0,r.jsx)(n.code,{children:"memorySnapshotIntervalSecs"})," has been replaced with top level ",(0,r.jsx)(n.code,{children:"systemInfoIntervalMillis"})," configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"maxUsedCpuRatio"})," has been moved to the top level configuration"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ProxyConfiguration.newUrlFunction"})," can be async. ",(0,r.jsx)(n.code,{children:".newUrl()"})," and ",(0,r.jsx)(n.code,{children:".newProxyInfo()"})," now return promises."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"prepareRequestFunction"})," and ",(0,r.jsx)(n.code,{children:"postResponseFunction"})," options are removed, use navigation hooks instead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"gotoFunction"})," and ",(0,r.jsx)(n.code,{children:"gotoTimeoutSecs"})," are removed"]}),"\n",(0,r.jsxs)(n.li,{children:["removed compatibility fix for old/broken request queues with null ",(0,r.jsx)(n.code,{children:"Request"})," props"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fingerprintsOptions"})," renamed to ",(0,r.jsx)(n.code,{children:"fingerprintOptions"})," (",(0,r.jsx)(n.code,{children:"fingerprints"})," -> ",(0,r.jsx)(n.code,{children:"fingerprint"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fingerprintOptions"})," now accept ",(0,r.jsx)(n.code,{children:"useFingerprintCache"})," and ",(0,r.jsx)(n.code,{children:"fingerprintCacheSize"})," (instead of ",(0,r.jsx)(n.code,{children:"useFingerprintPerProxyCache"})," and ",(0,r.jsx)(n.code,{children:"fingerprintPerProxyCacheSize"}),", which are now no longer available). This is because the cached fingerprints are no longer connected to proxy URLs but to sessions."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},14959:(e,n,s)=>{s.d(n,{Z:()=>c});s(67294);var r=s(39960),i=s(74477),o=s(52263),t=s(85893),l=s(50643).version.split("."),a=[l[0],l[1]].join(".");const c=function(e){var n=e.to,s=e.children,l=(0,i.E)();return(0,o.default)().siteConfig.presets[0][1].docs.disableVersioning||l.version===a?(0,t.jsx)(r.default,{to:"/api/"+n,children:s}):(0,t.jsx)(r.default,{to:"/api/"+("current"===l.version?"next":l.version)+"/"+n,children:s})}},11151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>t});var r=s(67294);const i={},o=r.createContext(i);function t(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(o.Provider,{value:n},e.children)}},50643:e=>{e.exports=JSON.parse('{"name":"crawlee","version":"3.7.1","description":"The scalable web crawling and scraping library for JavaScript/Node.js. Enables development of data extraction and web automation jobs (not only) with headless Chrome and Puppeteer.","engines":{"node":">=16.0.0"},"bin":"./src/cli.ts","main":"./dist/index.js","module":"./dist/index.mjs","types":"./dist/index.d.ts","exports":{".":{"import":"./dist/index.mjs","require":"./dist/index.js","types":"./dist/index.d.ts"},"./package.json":"./package.json"},"keywords":["apify","headless","chrome","puppeteer","crawler","scraper"],"author":{"name":"Apify","email":"support@apify.com","url":"https://apify.com"},"contributors":["Jan Curn <jan@apify.com>","Marek Trunkat <marek@apify.com>","Ondra Urban <ondra@apify.com>"],"license":"Apache-2.0","repository":{"type":"git","url":"git+https://github.com/apify/crawlee"},"bugs":{"url":"https://github.com/apify/crawlee/issues"},"homepage":"https://crawlee.dev","scripts":{"build":"yarn clean && yarn compile && yarn copy","clean":"rimraf ./dist","compile":"tsc -p tsconfig.build.json && gen-esm-wrapper ./dist/index.js ./dist/index.mjs","copy":"tsx ../../scripts/copy.ts"},"publishConfig":{"access":"public"},"dependencies":{"@crawlee/basic":"3.7.1","@crawlee/browser":"3.7.1","@crawlee/browser-pool":"3.7.1","@crawlee/cheerio":"3.7.1","@crawlee/cli":"3.7.1","@crawlee/core":"3.7.1","@crawlee/http":"3.7.1","@crawlee/jsdom":"3.7.1","@crawlee/linkedom":"3.7.1","@crawlee/playwright":"3.7.1","@crawlee/puppeteer":"3.7.1","@crawlee/utils":"3.7.1","import-local":"^3.1.0","tslib":"^2.4.0"},"peerDependencies":{"playwright":"*","puppeteer":"*"},"peerDependenciesMeta":{"playwright":{"optional":true},"puppeteer":{"optional":true}}}')}}]);